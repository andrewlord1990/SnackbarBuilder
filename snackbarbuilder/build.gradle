import static groovy.io.FileType.FILES

apply plugin: 'com.android.library'
apply plugin: 'jacoco'
apply plugin: 'com.github.kt3k.coveralls'

buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:1.3.0'
        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.0.1x'
    }
}

project.ext.set("versionMajor", 0)
project.ext.set("versionMinor", 1)
project.ext.set("versionPatch", 0)

project.ext.set("targetSdk", 23)
project.ext.set("minSdk", 7)

def generateVersionCode() {
    def minSdkPart = String.format("%02d", project.minSdk)
    def majorPart = String.format("%01d", project.versionMajor)
    def minorPart = String.format("%03d", project.versionMinor)
    def patchPart = String.format("%03d", project.versionPatch)
    return "${minSdkPart}${majorPart}${minorPart}${patchPart}".toInteger()
}

def generateVersionName() {
    return "${versionMajor}.${versionMinor}.${versionPatch}"
}

android {
    compileSdkVersion project.targetSdk
    buildToolsVersion "23.0.1"

    defaultConfig {
        minSdkVersion project.minSdk
        targetSdkVersion project.targetSdk
        versionCode generateVersionCode()
        versionName generateVersionName()
    }

    sourceSets {
        test.java.srcDirs += 'build/generated/source/r/debug'
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:support-v4:23.1.0'
    compile 'com.android.support:appcompat-v7:23.1.0'
    compile 'com.android.support:design:23.1.0'

    testCompile 'junit:junit:4.12'
    testCompile 'org.robolectric:robolectric:3.0'
    testCompile 'org.assertj:assertj-core:1.7.1'
    testCompile 'org.mockito:mockito-core:1.10.19'
}

jacoco {
    toolVersion = "0.7.1.201405082137"
}

task jacocoTestReport(type: JacocoReport) {
    group = "Reporting"
    description = "Generate Jacoco coverage reports"

    jacocoClasspath = project.configurations['androidJacocoAnt']

    def fileFilter = ['**/R.class', '**/R$*.class', '**/BuildConfig.*', '**/Manifest*.*', '**/*Test*.*', 'android/**/*.*', '**/*_.*']
    def debugTree = fileTree(dir: "${project.buildDir}/intermediates/classes/debug", excludes: fileFilter)
    def mainSrc = ['${project.projectDir}/src/main/java']

    sourceDirectories = files([mainSrc])
    additionalSourceDirs = files([mainSrc])
    classDirectories = files([debugTree])
    executionData = fileTree(dir: project.projectDir, includes: ['**/*.exec', '**/*.ec'])

    reports {
        xml {
            enabled = true
            destination = "${project.buildDir}/reports/jacoco/test/jacocoTestReport.xml"
        }
        csv.enabled false
        html {
            enabled = true
            destination = "${project.buildDir}/reports/jacoco"
        }
    }

}

// This task discovers the manifest files for the .aars that we depend on and
// adds them to project.ext.manifestFiles for use in later tasks.
task discoverManifestFiles(dependsOn: 'prepareDebugDependencies') << {

    def aars = new File(project.buildDir.absolutePath + "/intermediates/exploded-aar")
    def manifestFiles = new ArrayList<File>()

    // Iterate through the exploded-aars directory, finding the manifests
    aars.eachFileRecurse(FILES) {
        if (it.name.endsWith('AndroidManifest.xml') && !it.absolutePath.contains('aapt')) {
            manifestFiles.add(it)
        }
    }

    project.ext.manifestFiles = manifestFiles;
}

// After gradle's done compiling the code, it'll run this to add some more tasks for us.
afterEvaluate { project ->

    // Debug and release get their own tasks
    android.libraryVariants.each { variant ->

        // TODO extract from our manifest?  Should be on the build variant
        def myPackageNamespace = "com.andrewlord.snackbarbuilder"
        def myPackagePath = myPackageNamespace.replaceAll("\\.", "/")

        def processedPackages = new ArrayList<String>()

        // Task one of two that we're adding:  it depends on discovering manifest files
        // and on processing resources for this build variant.  It copies the merged R.java file
        // from our project's namespace (which contains the resource IDs included in our
        // dependencies) and drops it into each of our dependencies' namespaces.  This is to work
        // around limitations in robolectric.
        def copyRJavaTaskName = "copy${variant.name.capitalize()}RJavaForRobolectric"
        task(copyRJavaTaskName,
                dependsOn: ["process${variant.name.capitalize()}Resources", "discoverManifestFiles"]) << {

            // For each manifest file we discovered earlier, open it up an pull out the package
            project.ext.manifestFiles.each {
                def parsedManifestRoot = (new XmlParser()).parse(it.absolutePath)
                def targetPackageNamespace = parsedManifestRoot.@package

                // If it was already added, skip it
                if(!processedPackages.contains(targetPackageNamespace)){
                    processedPackages.add(targetPackageNamespace)
                } else {
                    println "WARNING:  Found two versions of $targetPackageNamespace; this could mess" +
                            " with your assets and resources"
                    // For some reason there are two versions of this dependency
                    // so skip additional iterations
                    return
                }

                def targetPackageNamespacePath = targetPackageNamespace.replaceAll("\\.", "/")

                // Copy R.java from our outputs into the namespace of each dependency
                // (and change the package line in the file, correspondingly)
                copy {
                    from "build/generated/source/r/${variant.name}/$myPackagePath"
                    include 'R.java'
                    into "build/generated/source/r/${variant.name}/$targetPackageNamespacePath"
                    filter { line -> line.contains("package ${myPackageNamespace};") ? "package ${targetPackageNamespace};" : line }
                }
            }
        }
        // Insert this new task into the task tree:  compiling unit tests depends on it.
        tasks.getByName("compile${variant.name.capitalize()}UnitTestJavaWithJavac") dependsOn copyRJavaTaskName


        // Second task we're adding:  copy lib assets into the place where robolectric expects them.
        // It depends on processing this variant's resources and on discovering manifest files.
        def copyAssetsTaskName = "copy${variant.name.capitalize()}AssetsForRobolectric"
        task(copyAssetsTaskName,
                dependsOn: ["process${variant.name.capitalize()}Resources",  "discoverManifestFiles"]) << {

            // For each manifest file we discovered, find that project's assets folder and copy it
            // to the same merged destination dir
            project.ext.manifestFiles.each {
                def manifestDirectory = it.parent

                def src = "${manifestDirectory}/assets"
                def dest = "build/intermediates/bundles/${variant.name}/assets"

                copy {
                    from src
                    include '**/*'
                    into dest
                }
            }
        }
        // Insert this new task into the task tree:  executing unit tests depends on it.
        tasks.getByName("test${variant.name.capitalize()}UnitTest") dependsOn copyAssetsTaskName
    }
}
